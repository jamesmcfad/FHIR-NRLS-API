---
title: Provider Guidance Overview
keywords: engage about
tags: [overview]
sidebar: overview_sidebar
permalink: provider_guidance_overview.html
summary: A overview of the guidance section for providers
---


## Overview



## Technical Stuff

## Pointer Identity

Once persisted within the NRL there are up to two ways to refer to a specific Pointer instance. Both are identifiers that are stored on the Pointer itself, but the master identifier is optional and is specified by the Provider.

- Logical identifier – This identifier is assigned by the NRL service when it persists a Pointer. It uniquely identifies that Pointer within the NRL service. The NRL service instance is the namespace for a given Pointer’s Logical identifier. 

- Master identifier – This also uniquely identifies the Pointer within the boundary of the NRL service. However, unlike the logical identifier, the master identifier is optional and is under the control of the Provider. For more details, see the [Master Identifier](#master-identifier) and [Uniqueness](#uniqueness) sections below.

### Logical Identifier

The logical identifier (ID) is generated by the NRL during the creation of a new Pointer. It is unique across all Pointers on the NRL service that created the Pointer. If the Pointer were ever to be migrated to a different NRL service instance then it is possible that its ID might need to change to avoid clashes with Pointers on the target NRL service.

The format of the ID is under the control of the NRL service. Clients should treat the id as an opaque identifier. In other words, the client should not make assumptions about the structure of the ID.

### Master Identifier

The master identifier is an optional identifier on the Pointer. It is under the control of the Provider. Guidance on the use of a unique master identifier value:

- Once a pointer with a master identifier value has been created, that same master identifier value must not be re-used with another pointer.
- 'Superseding' requires a new master identifier value. If a pointer is superseded, the new Pointer that replaces it must have a new, unique master identifier value.
- Once a pointer with a master identifier is deleted, the master identifier value used in that pointer cannot be used again on the NRL.

### Uniqueness

It is important that the master identifier be unique. The scope of that uniqueness is recommended to extend beyond the NRL service that the Pointer was originally created on. This is to support the notion that master identifier is a business identifier — it is tied to a specific Pointer and should never change regardless of which NRL service the Pointer is on.
In terms of the uniqueness of a given master identifier, a Pointer can be seen be seen as existing in a collection of namespaces:

* Patient — the smallest namespace in NRL. The set of master identifiers associated with a given Patient.
* Provider — this namespace spans Patients but is constrained to those Pointers owned by a given Provider.
* NRL — the largest namespace, which holds both the Patient and Provider namespaces.

Each of the namespaces are discussed in more detail below in particular who is responsible for ensuring that a given Master identifier is unique in that space and the consequences of failing to ensure uniqueness. Overall though, the content can be summarised as one strong recommendation to Providers:

***Providers should use a unique value for the Master identifier.***

### Patient Namespace

The NRL guarantees that no two Pointers for the same Patient (identified by NHS number) will have the same master identifier. If the Provider attempts to create a Pointer using a master identifier that has already been assigned to one of that patient’s other Pointers, the Provider’s request will be blocked.

### Provider Namespace

It is the Provider’s responsibly to ensure that the Master identifiers that it creates are unique across all of its own Pointers. It is perfectly possible for a Provider to create Pointers for different patients with the same master identifier. The NRL service will not prevent this scenario from arising.

### NRL Namespace

It is the Provider’s responsibly to ensure that the master identifiers that it creates are unique across all Pointers in the NRL. It is not unheard of for organisations to merge. In this case the Pointers previously owned by two organisations will come under the ownership of one of those organisations.

To provide the NRL with a degree of flexibility in terms of deployment, a Provider should not assume that there is a single instance of the NRL service. With this constraint in mind, the uniqueness of a Master identifier extends across NRL instances.

In the end, we arrive back at the recommendation made at the beginning of this section:

***Providers should use a unique value for the Master identifier.***

### Unique Value for the Master Identifier

The NRL recommends the use of a unique value when assigning a value for a Master identifier. To avoid the negative scenarios outlined above the value should be unique within the NRL namespace.

The problem of uniquely identifying an entity such as a Pointer is not a new one and there are several standard ways of generating a unique value. Two approaches of note are:

- The Universally Unique Identifier (UUID) – the uniqueness of a UUID is based on the extremely low chance that the same 128-bit random number will be generated twice. There exist a wealth of libraries that will generate a UUID that result in the practical likelihood that a UUID is unique being very high.

- Object Identifier (OID) – An OID is a set of decimal numbers called arcs that are separated by periods. The OID system relies on the concept of authorities who can hand out an OID that is guaranteed to be unique. From there, the owner of that OID can itself act as an authority handing out an arc to another organisation that is unique below the owner’s arc. This process can repeat and repeat creating a chain of arcs that are all unique within the scope of their parent arc.

As long as all organisations execute their responsibility to ensure uniqueness, the OID system provides a stronger guarantee of uniqueness than the UUID. However, it does rely on all members of an OID chain making sure that they do not reuse an value when assigning an arc to a child.



## Pointer Errors

The NRL API does not give Providers the ability to update the properties of an existing Pointer, other than the status property. The status property is modified in one of two ways.

The first is where a Provider replaces one DocumentReference with another, known as superseding. See [API Interaction - Supersede](api_interaction_supersede.html) for details.

The second is by performing a update to directly change the status of the pointer. See [API Interaction - Update](api_interaction_update.html) for details.

## Pointer Error Handling

Errors happen. It is important to acknowledge this reality and to design a solution with this in mind. To that end, the NRL makes a distinction between the following kinds of error:

* Errors with the Pointer metadata
* Errors with the content (record/document) that the Pointer references

## Errors with the Pointer Metadata

There are two scenarios in which a Pointer metadata error may occur:
* Error with the data that the Provider system is using to create a Pointer
* Defect in the Provider system that is creating and publishing Pointers

These errors may lead to one the following two situations:
* The Pointer itself should not have been added to the NRL
* It is valid for the Pointer to exist, but there are problems with the data stored on a Pointer. For example, the record creation date might be incorrect.

When the Provider realises there is a problem with the Pointer, action must be taken by the Provider. Depending on the nature of the problem, the Provider has different options when it comes to dealing with the issue.

### Pointer Should Not Have Been Added to NRL

In this case, as soon as the issue is recognised, the Provider should mark that Pointer’s status as entered-in-error.

Note that it is important to do this before that Pointer has been superseded, as once that transition has been made it is not possible to mark a Pointer as entered-in-error — see [Pointer lifecycle](pointer_lifecycle.html). Only those Pointers with a status of current can be moved to the entered-in-error state.

If a Provider finds that one of its superseded Pointers should not have been registered with the NRL, the entire lineage of that Pointer is considered corrupted. The Provider must mark the Pointer at the head of the lineage (the "current" Pointer) as being entered-in-error.

The Provider should then recreate a new "current" pointer with the correct information in place of the Pointer that was marked as entered-in-error.

### Pointer Data Is Invalid

Where the presence of the Pointer on NRL is valid but the data it holds is invalid, the Provider should update the pointer’s status to entered-in-error and create a new pointer that contains the correct data.

## Errors with the Content (Record/Document) that the Pointer References

The Provider should correct the content using whatever local processes are in place. This may necessitate the creation of a new version of the content, in which case it may be appropriate to replace the current Pointer with a new one. Alternatively, the correction to the content may be such that the existing Pointer transparently references the corrected content. In either case, responsibility for ensuring that the referenced content is correct rests with the Provider.

## Pointer Maintenance

The NRL allows a Provider to perform four interactions in relation to Pointers:
- Create — Results in the storage of a brand new Pointer in NRL
- Update — Modify the status of an existing Pointer in NRL
- Supersede — Replace a pointer. This interaction marks the pointer as superseded and creates a new Pointer in the NRL
- Delete — Remove an existing Pointer from NRL. This Pointer will no longer appear in search results

A Pointer’s main role is to refer to another entity, which is some kind of content. The content may be static or dynamic.

Because of this, when considering Pointer maintenance, we must consider the maintenance of two entities:
* Changes to the Pointer’s data — the referenced content has not changed, but one or more of the data items captured on the Pointer needs to be modified. In this case, Providers should supersede the existing resource, resulting in the creation of a new Pointer with updated data items.
* Changes to the referenced content — in this case, Providers should supersede the existing resource, resulting in the creation of a new Pointer that references the modified content.

## Creation of a New Pointer

The rules around when a Pointer is created will vary from Provider to Provider, because different business processes 
will be at play within their organisations. Having said that, there is some general guidance that can be given around when creation 
of a new pointer is appropriate.

As discussed in the [concepts section](overview_concepts.html), the NRL has the concept of a static and dynamic content in relation to what the Pointer is referencing. Static content will never change, whereas dynamic content is not guaranteed to be the same from one point in time to another in the future.

#### Static Content

Static content is typically content that undergoes version control. When a change is needed, rather than changing the content directly, 
a new version is created. This new version builds on the original and contains the modified content. Once the changes are complete, this new version is then considered immutable and becomes the current version, replacing the previous one. Rather than NRL holding one Pointer that references the current version of the content, it is recommended that Providers add a new Pointer for each version of their content. 

What constitutes a new version is left up to Providers, as it is difficult to prescribe a global versioning policy. What is expected, however, is that there is only ever one current version of a Pointer for an item of content. 

![Versioning of static content](images/pointers/pointer_maintenance1.png)

***Figure 1: How different versions of static content are reflected in NRL. For each new version of static content, a new Pointer is created with a status of current, and the previous version moves from current to superseded.***

#### Dynamic Content

Dynamic content makes none of the guarantees that static content makes. With static content, the consumer can be certain that the content will always be the same, regardless of the time it was retrieved. In contrast, dynamic content can vary depending upon when it was retrieved.

Dynamic content will typically be served up via an API. It is the lifecycle of the API that can be used to decide when referenced content has changed sufficiently to warrant an existing Pointer being superseded.

Examples of the kinds of things that Providers should consider as triggers to supersede a Pointer are:
* API contract
* API data sources
* API URL change or deprecation

#### API Contract

This involves changes to the way that a Consumer would interact with the API. This can cover changes in a number of areas:

- Data model — If the model that the content conforms to is changed, the Consumer may no longer be able to interpret the content.
- MIME type — If the format of the content as it is delivered to the Consumer changes, then Consumer may no longer be able to render the content.
- Security — If the mechanism for accessing secured content changes, the Consumer may not be able to access the content.
- Protocol — If the way the content is exchanged between Provider and Consumer changes, the Consumer may no longer be able to negotiate content retrieval.

#### API Data Sources

It is possible that the API is drawing data from multiple sources before aggregating the content ready for the Consumer. If the aggregating system is modified to draw data from additional sources, or one source is replaced with another, the content could be considered to have changed to such a degree that it should be reflected by superseding the current Pointer.

#### API URL Change Or Deprecation

If the URL of the API changes, or the API becomes deprecated, a new Pointer should be created and the old one marked as superseded to prevent Consumers from attempting to retrieve content from a non-existent or non-current location.

## Deleting an Existing Pointer

Deleting a Pointer should only be done in exceptional circumstances. Under most circumstances, a Pointer should be replaced (superseded). If the Provider realises that the Pointer is simply not valid, then it should be updated and marked as entered in error. If the Provider does want to delete the Pointer, it should be done as soon as possible after creation to limit exposure to Consumers. However, even in this circumstance, the Provider should consider marking the Pointer as entered in error instead.

{% include important.html content="When a Pointer is deleted from the NRL, it is marked as &quot;inactive&quot;, as opposed to being removed completely. This is commonly known as a &quot;soft deletion&quot;. Once a Pointer is deleted, the Pointer can no longer be viewed or edited by any Consumer or Provider." %}

## Updating an Existing Pointer

An update will be invoked on a Pointer when the Provider needs to change its status from current to entered-in-error. Providers can only change the status property on an existing Pointer. When any other attribute on the Pointer needs to be changed, the Pointer should be superseded, replacing it with an updated version. 

## Managing Pointers to Content

As noted above in the [overview](#overview) section, when a new version of content is created, a new Pointer should be created to reference the new content. Each time a new version of a Pointer is created, the existing one will be marked as superseded, and the new Pointer becomes current. For more detail, see Figure 2.

This is achieved through the combined use of three properties on the Pointer:
* Status
* Master identifier or logical identifier
* Related pointers

![Pointer versioning](images/pointers/pointer_maintenance2.png)

***Figure 2: How Pointer versions are maintained in NRL. Each time a new Pointer version is needed, the create message should reference the master identifier or logical identifier of the Pointer to be superseded.***

When the first version of a Pointer is created, the Provider specifies its status as current and can optionally assign a master identifier value (`1` in Figure 2). In this first version of the Pointer, the related pointers collection will be empty.

The end result of asking the NRL to create that Pointer is illustrated on the left-hand side of Figure 2 above – a Pointer has been persisted with a Provider-issued master identifier and a status of current.

At some point in the future, the Provider determines that a new version of the Pointer should be created, perhaps because the static content that the original Pointer references has changed. In this case, the Provider wants a new Pointer to be created to reference the new static content and the existing Pointer to be marked as superseded.

The NRL supports this transition by leveraging the related pointers property in conjunction with the status property and the master identifier or logical identifier. The Provider creates a new Pointer where the status is marked as current, with a master identifier value (`2` in Figure 2) that is different from the existing Pointer’s master identifier (see [Pointer identity](pointer_identity.html) for more detail), and the related pointers collection is populated with the master identifier of the existing Pointer (`1` in Figure 2). 

Upon receipt of this Pointer, the NRL resolves the related Pointer and sets its status to superseded. Once this is successfully completed, the NRL persists the new pointer. The end result is that the NRL is now in the state described above: two Pointers exist where one has been superseded by the other. This pattern of superseding can be repeated indefinitely by a Provider, leading to multiple superseded versions of a Pointer, but there can only ever be one current version.

## Pointer Lineage

A consequence of creating a relationship between Pointers where one supersedes another is that a lineage of Pointers is created.

In this context, "lineage" describes the line of descendants of an original Pointer. This line in effect describes each of the different versions of the content that each Pointer references. It is a view of the evolution of the content, with the oldest content being replaced by newer content.

![Pointer lineage](images/pointers/pointer_lineage.png)

***Figure 3: Pointer lineage. As soon as a Pointer is replaced (superseded) by another one, a lineage of related Pointers is created.***

Figure 3 above illustrates the lineage concept. Three Pointers exists in NRL (1, 2, and 3). Pointer 1 was the original and references content in the Provider’s system. After Pointer 1 was published, a new version of the content referenced was created. This triggered the Provider to publish a new Pointer (2) that superseded Pointer 1. Finally, the process was repeated with Pointer 3, which references the newest version of the content.




## HTTP Request

Retrieval of documents/records is achieved through an HTTP GET request. See the [Retrieval Read Interaction](retrieval_interaction_read.html) page for details of the requirements for responding to an HTTP GET request for retrieval.

## Provider Endpoint and Interaction ID Registration

Endpoints for retrieval must be registered on the Spine Directory Service (SDS). For the Beta phase, this will be done by the NHS Digital Deployment Issue and Resolution (DIR) team following completion of assurance.

The requirements for registering endpoints on SDS are as follows:

1. Every system MUST have a unique ASID for each organisation using it. For example, the same system deployed into three organisations would be represented by three unique ASIDs.
2. All interactions with the SSP MUST be over port 443.
3. Endpoints MUST NOT include explicit port declarations (e.g. `:443`).
4. Endpoints MUST have be registered with the interaction ID `urn:nhs:names:services:nrl:DocumentReference.content`.

See the [Spine Core specification](https://developer.nhs.uk/apis/spine-core/ssp_providers.html) for further detail on registering provider endpoints.

Providers MUST ensure that the record author ODS code on the pointer metadata matches the ODS code for the endpoint registered in SDS. This is required to enable Consumers to perform an SDS lookup to obtain the Provider system ASID and populate the Ssp-To header in the retrieval request. 

## Fully Qualified Domain Name (FQDN)

Following completion of assurance, Providers will be supplied with an [X.509 Certificate](https://tools.ietf.org/html/rfc5280){:target='_blank'} and an FQDN. The FQDN will form the base of Provider Endpoints as detailed above. For more details, see the [Security page](development_api_security_guidance.html).
